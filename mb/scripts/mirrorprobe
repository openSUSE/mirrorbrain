#!/usr/bin/python3

################################################################################
# mirrorprobe -- fetch mirrors from a database, try to access them and mark them
#                as "up" or "down".
#
# Copyright (C) 2007,2008,2009 Peter Poeml <poeml@cmdline.net>, Novell Inc.
# Copyright (C) 2007,2008,2009,2010,2011,2012 Peter Poeml <poeml@cmdline.net>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License version 2
# as published by the Free Software Foundation;
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
################################################################################


import sys
import os
import os.path
import time
import threading
import socket
import requests
import urllib
import urllib.error
import logging
import logging.handlers
from optparse import OptionParser
from sqlobject import *
from sqlobject.sqlbuilder import AND

import mb.appinfo
USER_AGENT = 'MirrorBrain Probe (see http://mirrorbrain.org/probe_info)'
DEFAULT_TIMEOUT = 20


def reenable(mirror):
    comment = mirror.comment or ''
    comment += ('\n\n*** reenabled by mirrorprobe at %s.' % (time.ctime()))
    mirror.comment = comment
    mirror.enabled = 1


def probe_http(mirror):
    """Try to reach host at baseurl. 
    Set status_baseurl_new."""

    try:

        logging.debug("%s probing %s" % (threading.currentThread().getName(), mirror.identifier))
        request_headers = {
            'User-Agent': USER_AGENT,
            'Accept': '*/*'
        }

        #req.get_method = lambda: "HEAD"

        mirror.status_baseurl_new = False
        mirror.timed_out = True
        mirror.response_code = None
        mirror.response = None

        url_to_scan = None
        if hasattr(mirror, 'url_to_scan'): 
            url_to_scan = mirror.url_to_scan
        if not url_to_scan:
            url_to_scan = mirror.baseurl

        if not url_to_scan:
            return None

        try:
            response = requests.get(url_to_scan, headers=request_headers)

            try:
                mirror.response_code = response.status_code
                # if the web server redirects to an ftp:// URL, our response won't have a code attribute
                # (except we are going via a proxy)
            except AttributeError:
                if 'location' in response.headers and response.headers['location'].startswith('ftp://'):
                    # count as success
                    mirror.response_code = 200
                logging.debug('mirror %s redirects to ftp:// URL' % mirror.identifier)

            logging.debug('%s got response for %s: %s' % (threading.currentThread().getName(), mirror.identifier, getattr(response, 'code', None)))

            mirror.response = response
            mirror.status_baseurl_new = True

        except ValueError as e:
            if str(e).startswith('invalid literal for int()'):
                mirror.response = 'response not read due to http://bugs.python.org/issue1205'
                logging.info('mirror %s sends broken chunked reply, see http://bugs.python.org/issue1205' % mirror.identifier)

        except socket.timeout as e:
            mirror.response = 'socket timeout in reading response: %s' % e

        except socket.error as e:
            #errno, errstr = sys.exc_info()[:2]
            mirror.response = "socket error: %s" % e

        except requests.HTTPError as e:
            mirror.response_code = e.responsse.status_code
            mirror.response = e.content

        except urllib.error.URLError as e:
            mirror.response_code = 0
            mirror.response = "%s" % e.reason

        except IOError as e:
            # IOError: [Errno ftp error] (111, 'Connection refused')
            if e.errno == 'ftp error':
                mirror.response_code = 0
                mirror.response = "%s: %s" % (e.errno, e.strerror)
            else:
                print(mirror.identifier, url_to_scan, 'errno:', e.errno)
                raise

        except Exception as e:
            print('unhandled exception %s' % e)
            print(mirror.identifier, url_to_scan)
            raise

    except Exception as e:
        mirror.response_code = None
        mirror.response = 'unknown error %s' % e

    # not reached, if the timeout goes off
    mirror.timed_out = False


def main():

    #
    # read config file
    #
    brain_instance = None
    if '-b' in sys.argv:
        brain_instance = sys.argv[sys.argv.index('-b') + 1]

    configpath = '/etc/mirrorbrain.conf'
    if '--config' in sys.argv:
        configpath = sys.argv[sys.argv.index('--config') + 1]

    import mb.conf
    import mb.mberr
    try:
        config = mb.conf.Config(conffile=configpath, instance=brain_instance)
    except mb.mberr.NoConfigfile as e:
        print(e.msg, file=sys.stderr)
        sys.exit(1)

    LOGLEVEL = config.mirrorprobe.get('loglevel', 'INFO')
    LOGFILE = config.mirrorprobe.get('logfile', '/var/log/mirrorbrain/mirrorprobe.log')
    MAILTO = config.mirrorprobe.get('mailto', 'root@localhost')

    #
    # parse commandline
    #
    parser = OptionParser(usage="%prog [options] [<mirror identifier>+]", version="%prog " + mb.appinfo.version)

    parser.add_option("--config",
                      dest="configpath",
                      default='/etc/mirrorbrain.conf',
                      help="location of the configuration file",
                      metavar="CONFIGPATH")
    parser.add_option("-b", "--brain-instance",
                      dest="brain_instance",
                      default=None,
                      help="name of the MirrorBrain instance to be used",
                      metavar="NAME")

    parser.add_option("-l", "--log",
                      dest="logfile",
                      default=LOGFILE,
                      help="path to logfile",
                      metavar="LOGFILE")

    parser.add_option("-L", "--loglevel",
                      dest="loglevel",
                      default=LOGLEVEL,
                      help="Loglevel (DEBUG, INFO, WARNING, ERROR, CRITICAL)",
                      metavar="LOGLEVEL")

    parser.add_option("-T", "--mailto",
                      dest="mailto",
                      default=MAILTO,
                      help="email adress to mail warnings to",
                      metavar="EMAIL")

    parser.add_option("-t", "--timeout",
                      dest="timeout",
                      default=DEFAULT_TIMEOUT,
                      help="Timeout in seconds (default: %ss)" % DEFAULT_TIMEOUT,
                      metavar="TIMEOUT")

    parser.add_option("-n", "--no-run",
                      dest="no_run",
                      default=False,
                      action="store_true",
                      help="don't update the database. Only look")

    parser.add_option("--client-ident",
                      dest="client_ident",
                      default="",
                      help="custom name to use while probe results (useful for troubleshooting)")

    parser.add_option("--variations",
                      dest="variations",
                      default=False,
                      action="store_true",
                      help="http/https variations of base_url")

    parser.add_option("-e", "--enable-revived",
                      dest="enable_revived",
                      default=False,
                      action="store_true",
                      help="enable revived servers")

    (options, args) = parser.parse_args()

    socket.setdefaulttimeout(int(options.timeout))

    # an "are you alive check" is relatively useless if it is answered by an intermediate cache
    for i in ['http_proxy', 'HTTP_PROXY', 'ftp_proxy', 'FTP_PROXY']:
        if i in os.environ:
            del os.environ[i]

    LOGFORMAT = '%(asctime)s ' + config.instance + ' %(levelname)-8s %(message)s'
    DATEFORMAT = '%b %d %H:%M:%S'

    #
    # set up logging
    #
    # to file
    logging.basicConfig(level=logging.getLevelName(options.loglevel),
                        format=LOGFORMAT,
                        datefmt=DATEFORMAT,
                        filename=options.logfile,
                        filemode='a')
    # to console
    #console = logging.StreamHandler()
    # console.setLevel(logging.getLevelName(options.loglevel))
    #formatter = logging.Formatter(LOGFORMAT, DATEFORMAT)
    # console.setFormatter(formatter)
    # logging.getLogger('').addHandler(console)

    # warnings will be mailed
    try:
        fromdomain = socket.gethostbyaddr(socket.gethostname())[0]
    except:
        fromdomain = ''
    toaddrs = [i.strip() for i in options.mailto.split(',')]
    mail = logging.handlers.SMTPHandler('localhost',
                                        'root@' + fromdomain,
                                        toaddrs,
                                        'no_subject')
    mail.setLevel(logging.WARNING)
    mailformatter = logging.Formatter(LOGFORMAT, DATEFORMAT)
    mail.setFormatter(mailformatter)
    logging.getLogger('').addHandler(mail)

    #
    # setup database connection
    #
    import mb.conn
    conn = mb.conn.Conn(config.dbconfig,
                        version=mb.appinfo.parsed_version,
                        debug=(options.loglevel == 'DEBUG'))

    if not options.no_run:
        from mb.mirrorscan import start_mirror_scan, finish_mirror_scan, isSsl

    #
    # get mirrors from database
    #
    mirrors = []
    if args:
        # select all mirrors matching the given identifiers
        result = conn.Server.select()
        for i in result:
            if i.identifier in args:
                mirrors.append(i)
    else:
        # select all enabled mirrors
        #
        # ignore wildcard mirrors, assuming that they can't be checked by normal means (i.e., baseurl itself may
        # not give a 200. Just some files are served maybe...
        result = conn.Server.select(AND(conn.Server.q.enabled, conn.Server.q.country != '**'))
        for i in result:
            mirrors.append(i)

    if not mirrors:
        sys.exit('no mirrors found')

    #
    # start work
    #
    logging.info('----- %s mirrors to check' % len(mirrors))

    concurrency = min(16,len(mirrors))
    from queue import Queue
    from threading import Thread
    probe_queue = Queue()
    
    for i in range(min(concurrency, len(mirrors))):
        Thread(target=probe_http_queue, args=(i, probe_queue, ), daemon=True).start()

    for i, mirror in enumerate(mirrors):
        print('Queuing:', mirror.id)
        probe_queue.put((mirror, options, False))
        if options.variations:
            probe_queue.put((mirror, options, True))

    print('*** Main thread waiting')
    probe_queue.join()
    print('*** Done')
    sys.exit(0)

def probe_http_queue(i, q):
    while True:
        print('%s: Looking for the next enclosure' % i)
        tpl = q.get()
        if tpl is None:
            time.sleep(1)
            continue
        print(tpl)
        do_probe_mirror(tpl[0], tpl[1], tpl[2])
        q.task_done()

def do_probe_mirror(mirror, options, alternative = False):
    scan = None
    if not options.no_run:
        from mb.mirrorscan import start_mirror_scan, finish_mirror_scan, isSsl
        is_ssl = isSsl(mirror.baseurl)
        if alternative:
            is_ssl = not is_ssl
        print('%s: baseurl %s | is_ssl %s | alternative %s' % (mirror.identifier, repr(mirror.baseurl), repr(is_ssl), repr(alternative)))
        scan = start_mirror_scan(mirror._connection, mirror.id, options.client_ident, mb.mirrorscan.ScanScheme.Http, is_probe = True, is_ssl = is_ssl)
    try:
        success = False
        if not options.no_run and scan is None:
            logging.debug('%s: baseurl %s: cannot start scan' % (mirror.identifier, repr(mirror.baseurl)))
            return False
        success = _do_probe(mirror, options, alternative)
    finally:
        if scan is not None:
            finish_mirror_scan(mirror._connection, scan, success)
    return success

def _do_probe(mirror, options, alternative):
    if True: # this if is temporary to limit diff noise
        probe_http(mirror)
        will_update = (not options.no_run and ((not hasattr(mirror, 'url_to_scan')) or mirror.baseurl == mirror.url_to_scan or (not mirror.url_to_scan)))
        logging.debug('%s: baseurl %s / baseurl_new %s / will update %s' % (mirror.identifier, repr(mirror.statusBaseurl), repr(mirror.status_baseurl_new), repr(will_update)))
        # old failure
        if not mirror.statusBaseurl and not mirror.status_baseurl_new:

            if mirror.response_code and (mirror.response_code != 200):

                mail.getSubject = lambda x: '[%s] mirrorprobe warning: %s replied with %s' \
                    % (config.instance, mirror.identifier, mirror.response_code)

                logging.debug("""%s: (%s): response code not 200: %s: 
I am not disabling this host, and continue to watch it...
""" % (mirror.identifier, mirror.baseurl, mirror.response_code))

                # reset the getSubject method...
                mail.getSubject = lambda x: 'no subject set'

                #comment = mirror.comment or ''
                #comment += ('\n*** mirrorprobe, %s: got status code %s' % (time.ctime(), mirror.response_code))
                logging.debug('setting enabled=0 for %s' % (mirror.identifier))
                if will_update:
                    # mirror.enabled = 0
                    mirror.statusBaseurl = 0
                    #mirror.comment = comment

            logging.debug('still dead: %s (%s): %s: %s' % (mirror.identifier, mirror.baseurl, mirror.response_code, mirror.response))

        # alive
        elif mirror.statusBaseurl and mirror.status_baseurl_new:
            logging.debug('alive: %s: %s' % (mirror.identifier, mirror.response))
            if mirror.enabled == 0 and options.enable_revived:
                logging.info('re-enabling %s' % mirror.identifier)
                if will_update:
                    reenable(mirror)

        # new failure
        elif not mirror.status_baseurl_new and mirror.statusBaseurl:
            logging.info('FAIL: %s (%s): %s' % (mirror.identifier, mirror.baseurl, mirror.response))
            logging.debug('setting status_baseurl=0 for %s (id=%s)' % (mirror.identifier, mirror.id))
            if will_update:
                mirror.statusBaseurl = 0

        # revived
        elif not mirror.statusBaseurl and mirror.status_baseurl_new == 1:
            logging.info('REVIVED: %s' % mirror.identifier)
            logging.debug('setting status_baseurl=1 for %s (id=%s)' % (mirror.identifier, mirror.id))
            if will_update:
                mirror.statusBaseurl = 1
            if options.enable_revived:
                logging.info('re-enabling %s' % mirror.identifier)
                if will_update:
                    reenable(mirror)

        return mirror.response_code is not None and mirror.response_code < 300


if __name__ == '__main__':
    main()
